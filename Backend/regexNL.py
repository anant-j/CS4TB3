"""
CS4TB3 Winter 2022 Final Project
Group: 14
Authors: Anant Jain, Kuber Khanna, Bilaval Sharma
Demo Available At: https://bit.ly/regexNL
To run locally:
- set debugMode = True
- Call parse("regexInput") at the end of the file
"""

# Importing libraries
import random
import sre_parse
import re
import exrex
from patternRecognizer import patternRecognition
import time

# Parameters Setup:
debugMode = False  # Prints debug and performance info in terminal if True
# Maximum number of repetitions allowed for wild characters (like * and +)
maxRepeatLimit = 4

# Maximum number of results generated by the procedural generation algorithm
maxProceduralAllowedResults = 10000
# Maximum number of random results selected from the set of procedurally
# generated permutations
maxSampleSize = 1000

# Maximum number of results generated by the random generation algorithm
maxRandomAllowedResults = 7500
maxFallback = 250  # Maximum consecutive collisions allowed for a given permutation before the algorithm terminates

# Character class setup
digitsList = list("0123456789")
lowercaseLetters = list('abcdefghijklmnopqrstuvwxyz')
uppercaseLetters = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
complexCharacters = list('*+[,{')
disallowedCharacters = list('^')
validRegexCharacters = list("*+?()[]{}|$\ ")
symbols = list("!#$%&,-./:;<=>@[]_`~")
globalCharacterSet = digitsList + lowercaseLetters + uppercaseLetters + symbols


# Returns the maximum number of repetitions allowed for a given wild character
# Output type depends on the paramters passed
def limits(inptype, value):
    if(inptype == "string" and str(value) == "MAXREPEAT"):
        return "infinite"
    elif(inptype == "value" and str(value) == "MAXREPEAT"):
        return maxRepeatLimit
    else:
        return value


# Perform Complexity Analysis by counting "wild" characters
# Validate if an invalid or unsupported character is present in the regex
def preParseComplexityAnalyser(inputStr):
    complexityLevel = 0
    for i in inputStr:
        if (i in disallowedCharacters or i not in (
                globalCharacterSet + validRegexCharacters)):
            return [False, f"Disallowed character found: {i}"]
        if i in complexCharacters:
            complexityLevel += 1
    if complexityLevel > 10:
        return [False, "This regex is too complex to process"]
    else:
        return [True]


# Global variable for managing spacing
depthLevel = 0
subpatternRecognized = False


# Method that:
# Converts regex to AST
# Converts AST to Text Output
# Used AST to generate permutations
# Perform pattern analysis
def parse(inputStr):
    global depthLevel
    global subpatternRecognized
    depthLevel = 0
    subpatternRecognized = False
    start = time.time()  # Start time for performance analysis
    try:
        re.compile(inputStr)
    except re.error:
        if(debugMode):
            print("Invalid regex")
        return {"success": False, "reason": "Regex is invalid"}
    # Perform pre parse complexity analysis
    complexity = preParseComplexityAnalyser(inputStr)
    if(complexity[0] is False):
        if(debugMode):
            print(complexity[1])
        return {"success": False, "reason": complexity[1]}
    try:
        parsed = sre_parse.parse(inputStr)  # Generate AST
        explanation = stringify(parsed)  # Convert AST to Text Output
        allPermutations = set()
        randomPermutations = generateRandomPermutations(
            parsed)  # Generate random permutations
        proceduralPermutations = generateProceduralPermutations(
            inputStr)  # Generate procedural permutations
        # Combine random and procedural permutations
        allPermutations = randomPermutations.union(proceduralPermutations)
        # Perform pattern recognition/analysis
        pattern = patternRecognition(allPermutations, inputStr)
        if(debugMode):
            end = time.time()
            print(f"Parsing {inputStr}")
            print(f"AST: {parsed}")
            print(f"Explanation: {explanation}")
            print(pattern)
            # print(allPermutations)
            print(len(allPermutations))
            print(end - start)
        return {
            "success": True,
            "explanation": explanation,
            "patterns": pattern,
            "permutations": list(allPermutations)
        }
    except Exception as e:
        if debugMode:
            print(e)
        return {
            "success": False,
            "reason": e,
        }


newLineChar = '\n'
tabSpaceChar = '\t'


# Method to convert AST into Human Readable Text Output
def stringify(val, literal=True):
    global depthLevel
    global subpatternRecognized
    if(isinstance(val, sre_parse.SubPattern)):
        outputstr = ""
        for i in val:
            outputstr += stringify(i, literal)
        return outputstr
    else:
        if(str(val[0]) == "LITERAL"):
            if(literal):
                return f"{newLineChar}{tabSpaceChar * depthLevel}Character: {chr(val[1])} "
            else:
                return f"{chr(val[1])}"
        elif(str(val[0]) == "CATEGORY"):
            if(str(val[1]) == "CATEGORY_WORD"):
                return "A-Za-z0-9"
            elif(str(val[1]) == "CATEGORY_DIGIT"):
                return "0-9"
            elif(str(val[1]) == "CATEGORY_SPACE"):
                return "Any white space character"
        elif(str(val[0]) == "MAX_REPEAT"):
            if val[1][0] == val[1][1]:
                strToReturn = f"{newLineChar}{tabSpaceChar * depthLevel}Repeated {val[1][0]} times: "
                depthLevel += 1
                strToReturn += f"{tabSpaceChar * depthLevel}{stringify(val[1][2], True)}"
                depthLevel -= 1
            else:
                strToReturn = f"{newLineChar}{tabSpaceChar * depthLevel}Repeated between {val[1][0]} to {limits('string',val[1][1])} times : "
                depthLevel += 1
                strToReturn += f"{tabSpaceChar * depthLevel}{stringify(val[1][2], True)}"
                depthLevel -= 1
            return strToReturn
        elif(str(val[0]) == "SUBPATTERN"):
            subpatternRecognized = True
            generatedOutput = f"{newLineChar}{tabSpaceChar * depthLevel}"
            for i in val[1][3]:
                generatedOutput += f"{stringify(i, False)}"
            return f"{generatedOutput}"
        elif(str(val[0]) == "BRANCH"):
            generatedOutput = ""
            if(not subpatternRecognized):
                generatedOutput += f"{newLineChar}{tabSpaceChar * depthLevel}"
            generatedOutput += "One of: ("
            depthLevel += 1
            for i in val[1][1]:
                generatedOutput += f"{newLineChar}{tabSpaceChar * depthLevel}{stringify(i, False)}"
                if(i != val[1][1][-1]):
                    generatedOutput += ","
            depthLevel -= 1
            return f"{generatedOutput}{newLineChar}{tabSpaceChar * depthLevel})"
        elif(str(val[0]) == "IN"):
            if len(val[1]) > 1:
                generatedOutput = ""
                if(not subpatternRecognized):
                    generatedOutput += f"{newLineChar}{tabSpaceChar * depthLevel}"
                generatedOutput += "One of: ("
                depthLevel += 1
                for i in val[1]:
                    generatedOutput += f"{newLineChar}{tabSpaceChar * depthLevel}{stringify(i, False)}"
                    if(i != val[1][-1]):
                        generatedOutput += ", "
                depthLevel -= 1
            else:
                generatedOutput = f"{newLineChar}{tabSpaceChar * depthLevel}("
                depthLevel += 1
                for i in val[1]:
                    generatedOutput += f"{newLineChar}{tabSpaceChar * depthLevel}{stringify(i, False)}"
                    if(i != val[1][-1]):
                        generatedOutput += ","
                depthLevel -= 1
            return f"{generatedOutput}{newLineChar}{tabSpaceChar * depthLevel})"
        elif(str(val[0]) == "RANGE"):
            generatedOutput = f"Symbol in range: {chr(val[1][0])} - {chr(val[1][1])}"
            return generatedOutput
        elif(str(val[0]) == "ANY"):
            generatedOutput = "Any character"
            return generatedOutput
        else:
            if(len(val) != 1):
                raise Exception("Regex cannot be parsed")
            return val

# Method to generate a random permutation from given AST
def generateVariation(val):
    if(isinstance(val, sre_parse.SubPattern)):
        outputstr = ""
        for i in val:
            outputstr += generateVariation(i)
        return outputstr
    else:
        if(str(val[0]) == "LITERAL"):
            return f"{chr(val[1])}"
        elif(str(val[0]) == "CATEGORY"):
            if(str(val[1]) == "CATEGORY_WORD"):
                return random.choice(globalCharacterSet)
            elif(str(val[1]) == "CATEGORY_DIGIT"):
                return random.choice(digitsList)
            elif(str(val[1]) == "CATEGORY_SPACE"):
                return " "
        elif(str(val[0]) == "MAX_REPEAT"):
            times = random.randint(val[1][0], limits('value', val[1][1]))
            i = 0
            strToReturn = ""
            while(i < times):
                strToReturn += f"{generateVariation(val[1][2])}"
                i += 1
            return strToReturn
        elif(str(val[0]) == "SUBPATTERN"):
            generatedOutput = ""
            for i in val[1][3]:
                generatedOutput += f"{generateVariation(i)}"
            return f"{generatedOutput}"
        elif(str(val[0]) == "BRANCH"):
            return generateVariation(random.choice(val[1][1]))
        elif(str(val[0]) == "IN"):
            return generateVariation(random.choice(val[1]))
        elif(str(val[0]) == "RANGE"):
            return(random.choice(charToRange(chr(val[1][0]), chr(val[1][1]))))
        elif(str(val[0]) == "ANY"):
            return generateVariation(random.choice(globalCharacterSet))
        else:
            if(len(val) != 1):
                raise Exception("Regex cannot be parsed")
            return val

# Method to generate maximum random permutations until
# maxRandomAllowedResults is reached or no more permutations are possible
def generateRandomPermutations(inp):
    outputSet = set()
    fallback = maxFallback
    while(fallback > 0):
        result = generateVariation(inp)
        if(result in outputSet):
            fallback -= 1
        else:
            fallback = maxFallback
            outputSet.add(result)
        if(maxRandomAllowedResults is not None and len(outputSet) >= maxRandomAllowedResults):
            break
    return outputSet


# Method to generate maximum procedural permutations until
# maxProceduralAllowedResults is reached or no more permutations are
# possible
def generateProceduralPermutations(inputStr):
    # Using exrex library AS-IS with no modifications
    generator = exrex.generate(inputStr, maxRepeatLimit)
    num = 0
    allPermutations = set()
    while num < maxProceduralAllowedResults:
        try:
            allPermutations.add(generator.__next__())
        except BaseException:
            break
        num += 1
    sampleSize = len(allPermutations)
    if(len(allPermutations) > maxSampleSize):
        sampleSize = maxSampleSize
    # Get a random subset of all the procedurally generated permutations
    somePermutation = random.sample(list(allPermutations), sampleSize)
    return somePermutation


# Auxiliary mathod to retrieve range of characters in a list format from the lower and upper bound.
# Used in Random Permutations Generation
def charToRange(left, right):
    if(left == right or not isinstance(left, type(right))):
        return "error: type cannot be different for range"
    if(isinstance(left, int) and isinstance(right, int)):
        return list(range(left, right))
    else:
        return list(map(chr, range(ord(left), ord(right) + 1)))
